{-# OPTIONS_HADDOCK hide #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell #-}

import           System.IO (BufferMode(..), hSetBuffering, stdout, stderr)
import           System.Exit (exitFailure)
import           Data.Maybe (isJust, fromJust)
import           Control.Monad (unless)
import           Control.Monad.Catch (MonadCatch(..))
import           Hedgehog
import qualified Hedgehog.Gen as Gen
import qualified Hedgehog.Range as Range
import           Data.Array
import           Codec.Binary.QRCode


shortFailures :: [(Int, ErrorLevel, Mode, String)]
shortFailures =
    -- https://github.com/kizzx2/haskell-qrcode/issues/7
    [ (1, H, Numeric, "268")
    -- https://github.com/kizzx2/haskell-qrcode/issues/5
    , (40, L, Alphanumeric, "16-KVRR2GX*O31Z4OPG.V.1U:L439+IO6GBLHXE5XBU-VML$84-K %NQ6Z ED000N9I.3.TV:QBSNUU000SAX3V%D+1NZL:Q7:R0G27ODAPBAS6X XJKX KBIBZSU647720$1K*I$3QU2D79FOLJ $WP5T9SH%A2L%J*L::*B$Q$9V3ITWSMYRFZGM1BT+2KYPXA+RIFS1O*SLB8*VN1W-XD*ZH%IN:JGDU5TJ:STH3T$ 3DQHRHL2C*535$*UA4PV+5::3E.S$U:84N6SL*.1$5QEBS$7*F2YG.U2B$B6E26480:+RQ$ZG2E*7G$%SW7%5KZVPYIQ76A-$D+:71:H:PQOU51O8W9C%KMBD8IWDKB$AMVNKO5N09S4D3JSYR LVDYVDB4 V*T4VYH$D3D0RE3KAN:RP6LGJZYN*H5TF34W%SX:ZV216Y XY%.CUN0CDT15+1LE1Z9TNV+0B1:O2D2:300RW1NHJMYT.BW+4UQED0W.FSI4%MQC8X-GEQY:8LHO5ID%O8I8MT.%2YNC21MJCNML.M4I1J3PM-$1R01VANGOS.TIZRF8 C+WY:8%SN0CK+VD8*O*KWVFX7WPZ:SN$C93RYM$2+NLA%CO:9NDM7WZ*-DU9ZY45C:412HDEY%MN4O2-:::*I4TC2411NPZ$.YF7VQ.UORG:Z5 :4M:.:33HU*$R12+*USGHY%.E35WPYKAZI$8L74:TQ7AZZ+AYV8NDBPUU$2 YD%*W8Y%O24 B-MAU+%+5$2 6.1I+DNZY*-14J$R %N6SHD05SD*A54KA$43AG92T %3:8:A9ZCQSPNS5YRY$ZKUKJ$%LI$%0H:48+:PN*AAY%SG+Y:KS .BDU6HO:NY7*Q:ZB$6N4 ZRBEA6K328$+35JMPFY-T6:13PTM*6O%2 +AOKEG:-T6UUC+OZ8H:*TUAYUN*W329R8:C7**KSEVHW7O$CW 82QUF4FXE6LI5GOH :-C 0 0L*6WT59V1:RBMX0SL2.1DYH-0P3XS%:-MOVJWWK--MTQ+K40BZZ8O4BF2MFHZ9X6VXYB-OLEH-9.JX0FB+KL38UM7:M84WVAU1:M2YBTJ5WWK5-7WI65J*5CG58:%JAO9B3D+AMF1:*NQBQ3:+:RFK2SL829IKH*E*AEAXEAQVG7Z+CMU$EK3.512EHZTV*A:UPC69JB77G4.NH5.UT.53:ETBA3Y1CMFLXD11:Z*E%8%5$X5G08ECC-2K:3ANLBP*O.%1PI$U:$XEB*%IJ0JY .N::IDVDFKP8M E.91UIMXL+WT6%6TKW0$6 W:P-*J%JN4$-U2OLL+1FIX8UIBWHNN:PB0HDOOECAW5M1AOW%CIXDMXFO6J-EV0B:Q%8C44DCN:-OT6ODW9-KDDF1AC0NPS5IJ8MEGR41%KBDX2LC:*ROM5RB$1Q 1VOW*8N9-P8$M686TL4P+EIJ117KNSZ9B0E8M79DGS-:GDN1H56I-8YQ697O2C3R5$0E2ZRXH*IJ.J.*ULC %5BYBQ66F5AVQ+UZA3Q$T%3-W4VWWLWO ZDE4DFUA6VWKLTD*LD6+UBDTYU+LJMN.341 4 0XW%EG:M+7VCXSOZT$G1MD-TS6JG.%D4SEBL5AA-4T W9D.BE*4G0:3*ZF2*KO::7FS2C.+7K0.LERFQ7HOZPCYYS8RNS%+PNDS 4BJM6C3BLB7J-J:K+N573QOX.JPY8IL M7I6MBZDX8VXTLBUEEUHJGJN%K+OJEUV2HFSMQ5PLMDE$AEN.WN2S0I1V52-6$Q6A41A8-7KIBI6:L7177AI5YVR2PQW EM%D MZ7BI6VTF:PO0W7QKG3-RBKKFEP62OPA%AQEM.%974ON5.HQOEMDC3Y:3GKT$0PV%UCNTUJO.9KCLTZ53*VD97V+MFBZ90UHDR ZQ V*9- HQOJ31BT36+66G1M:YEE8Q3N:97T4WU8G:TW%V8-6O%GTOEAEM74.H8IIUM::XYZL4VPIINMLZJEH4J1UBBOP%71:Z+-0VWYRVI817-1I4ZW+K0%6N628%E.2UBEJC74IIH7 :CYN30FG+P99ABEQ*O 0X40MKY8S6MQ3CVKR402Q8J73:90$N07V68:F9K3TCZOY0EU*V4:.L3ES6KSG6U0:C0.*D$DWMT0CT8-F933 L3 XT1HHJZVSCRY:6.D$KOC5UGX4:+H0*0BOI%ZYK:F*AH-:4K7XJ$K9%TE6XKNN GD U+F1S 08-S$5:E0J943VP2SGH2RO3CGPYSK78 8TB61T-R0P$9SY.%Z1:A-% 4VZ0AKXKC-6KE:16N573B-$IK2M5 D*P$SBBQOPYSG IA2U-:01S:A..BMVOBX68C:A87D*8JQ5UVD*7-RF*M7EX%CM%VLO85LQ2ODJ9ADRS$3::FT-C4:V:1%94FOCSQ* 0RS$ABC:YGIW---KD:6K1$LILPMWSMYVW0T:*7SFX W3L8ME9:X:4%VQF%SN70X9O C%N8J2SX*:$H5%B-3$*M-:LZ:1226$.AE.+W+MBJQI3.IE$-H5O3GX41U4XH6:6ZK5LE F+Z6TIX.TYLWGFM1DOE7FC*M*0ZKWIC+XD5TA*CALTR3+A+8GO$$*UQ-PD7G 8QWQ462CK0C2UWU-+:QN+ZSD O7DMG3G:449EPC7D3B%PO::D2V4CZ H%RHUXZDM$XWO$U-X-7A2Y6V7EMP.:G4IY57 0V0JM:OVN+6I::42J:8Z5PP2NY2G4G$25FHGD:1C03:FU$QZ5QD7FPPD5CR9H00J0L1PMO9RF2EBNVA6S:14W8JYA4YYY2 -ZPMM-F4EB238.371Z8FRJY$9I0 OP$ QCVCF+Y8DSQMY8O0P0904T-XQ1.-HD22K2M6MGU.2KWHJ9GTYD Z9HE4SHS90TUPT5TGLS64TG7HYO%*QM$80Q:O4YIPCCL6LWF676TW3T.Z.T6M5*-Z$4T4O$ 0IPYSZSU*D528U.4I1KGQF-G$H40C0UWRL X05U4:ZFR.2FF$OZ6G:ZHC6182  *$0NG+*PK.L6R7N280RDX4LDS16:J-KT1DXA N4ZZS02JULC90H4U8MSE6:WE-*I CV:ER*+R912DGRKT$MLH:B209CW319$-YA.1STH16UIRJ9IZ-YRE*HIX3+:0%BVM.3K+ D7.C.LV++YG.0L0Y7:*70I*L+N%P2EAW56:LRK1IX0K$EV0+VTDUT4V Y3MTF+W.*KWMDJZBXZI2 A.O5 PVI-4+IU$ +.M8CVV1:T-63FLB8HONIBTURTQXGWLFZVRH8LM$%WEF$6$MN$PORKEVNX*GQ J4XTCMOD-:$:DZE4L6+R07A1V1V:DOYY  M0:RF1*OY.*-RXRY-:O5UHDUMSMIKVT1AZEA-OI7OS*59 S4E320X4BC$GZJP:9S412.DJ9Z3D2*:2RT2I9D+TR7F7P 1$15GVRDZ.DW-689JF5H:0NRNMUHO2LY+.LQ49:JNC6XQ:-9 XU67IPLJPH2*XL3E6LJM*XVLJ%K%2N9I09RT2:T5CLTI:63-EQ*O:0G4W:HH$QPT::+9*E10R4ON+6S960:CSP57C.TNZ7P6LM$TA9.U%B5.U*VSW0ERV1AX.MP-X70AAEG0O5: CD-UE2AMFOU-+5ZTRPQK:YU7QCZ X$N.M.CQ4+ N26R8XO3WA2IKRUPJMIQLMKNLG.BY1DF%0$U3A:CIX- C4LE6E9E9AQ8WFMC*O:*SEIF:1X495TAK81E0-OCR4DKTJ2WGUFC2S.:9:D0HL:EE+.4C.F5G02Y+$P*-7M+ 1ILQAXGL%D61TX2XA7YK8DK:QL82GHB5B5UAD:8*$06T:+5TL*.8:2KP6J:10N30FFXWP4T%QVXC%:4G:U:75-:9:2:W*DOPVAAW0%FC%S ROZV31.BA$SLOHQBI.A1B5DE2G+.0GA XGTJFAFX*H9CR03Z75CRIXAPA56I+LJ7HFGPQ2K%P.*XF.IJO:Y E3.Q-:%86:*I3P NP7FV714-SOQ $5 :17P.HSQ8Q3TDXTU08%2KPRZHD%2HFJEUOK+U:TT*QTK00M:+4U59B68*A67PZ2LY%I:XE7 R0S-FMS.D7RY3DE.%GKB2S 9VV.9%WN NHKJN-SFKJF7KI3G8BZ8EA1%C6D U:-6A50X6F-QAX*E.3PPAU0HRDHLPF:%W*WPJ3-W%U*:4M6X48:O63.G077C.2UVYODRUL:E:YY+NF31AJ2WU")
    -- https://github.com/kizzx2/haskell-qrcode/issues/1
    , (15, L, Alphanumeric, "HELLO WORLD HELLO WORLD HEHELLO WORLD HELLO WORLD HEHELLO WORLD HELLO WORLD HEHELLO WORLD HELLO WORLD HEHELLO WORLD HELLO WORLD HEHELLO WORLD HELLO WORLD HEHELLO WORLD HELLO WORLD HEHELLO WORLD HELLO WORLD HEHELLO WORLD HELLO WORLD HEHELLO WORLD HELLO WORLD HE")
    , (7, Q, EightBit, "\NUL")
    , (5, Q, EightBit, "\NUL\NUL\NUL\NUL\NUL\NUL")
    , (2, Q, Alphanumeric, "0PA8M")
    , (4, H, Alphanumeric, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN5XMFYZDNCM5UH")
    , (13, Q, Alphanumeric, "T1JPZRXUGST$M%::J")
    , (16, H, Alphanumeric, "0000000000000000000000000000000000000000000000000000000000000000")
    , (7, M, Numeric, "7038935389817588382403234418665196039788216355301578947135350196854")
    ]

alphaNumeric :: Gen Char
alphaNumeric = Gen.element "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:"

assertMatrix :: (MonadTest m, MonadCatch m) => Maybe Matrix -> m ()
assertMatrix m = do
    assert . isJust $ m
    -- Collect all of the undefined indices
    let arr = toArray (fromJust m) :: Array (Int, Int) Bool
    evalM $ mapM_ (\e -> e `seq` pure ()) (elems arr)

prop_shortFailures :: Property
prop_shortFailures =
    property $ do
        (v, e, m, s) <- forAll $ Gen.element shortFailures
        assertMatrix $ encode (fromJust $ version v) e m s

prop_encode_alphanumeric :: Property
prop_encode_alphanumeric =
    property $ do
        Just ver <- forAll $ version <$> Gen.int (Range.linear 2 20)
        e <- forAll $ Gen.element [ L, M, Q, H ]
        s <- forAll $ Gen.string (Range.linear 1 1000) alphaNumeric
        assertMatrix $ encode ver e Alphanumeric s

prop_encode_numeric :: Property
prop_encode_numeric =
    property $ do
        Just ver <- forAll $ version <$> Gen.int (Range.linear 2 20)
        e <- forAll $ Gen.element [ L, M, Q, H ]
        s <- forAll $ Gen.string (Range.linear 1 1000) Gen.digit
        assertMatrix $ encode ver e Numeric s

prop_encode_eightbit :: Property
prop_encode_eightbit = property $ do
    Just ver <- forAll $ version <$> Gen.int (Range.linear 4 20)
    e <- forAll $ Gen.element [ L, M, Q, H ]
    s <- forAll $ Gen.string (Range.linear 1 1000) Gen.latin1
    assertMatrix $ encode ver e EightBit s

tests :: IO Bool
tests =
  checkParallel $$(discover)

main :: IO ()
main = do
    hSetBuffering stdout LineBuffering
    hSetBuffering stderr LineBuffering
    result <- tests
    unless result exitFailure
